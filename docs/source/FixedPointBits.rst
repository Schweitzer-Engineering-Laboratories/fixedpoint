..  currentmodule:: fixedpoint

..  _FixedPoint_slicingandmapping:

###############################################################################
The **FixedPointBits** Class
###############################################################################

..  admonition:: Examples are just a click away
    :class: example

    Boxes like this link to example code.

..  class:: FixedPointBits

        ``FixedPointBits`` inherits from :class:`int` and adds item access.
        You should not need to instantiate this, but this allows for the
        :attr:`.FixedPoint.bits` attribute to be indexed, sliced, and mapped.

    ..  attribute:: s

        :type:
            |bool|_

        :value:
            *True* for signed, *False* for unsigned.

    ..  attribute:: m

        :type:
            |int|_

        :value:
            Number of integer bits.

    ..  attribute:: n

        :type:
            |int|_

        :value:
            Number of fractional bits.

    ..  method:: __getitem__(key)

        ..  note::

            This is the built-in square bracket ``[]`` operator.

        :param key:
            Bit index, slice, or mapping

        :type key:
            int or slice or str

        :rtype:
            int or str

        :raises KeyError:
            Unsupported mapping string

        :raises IndexError:
            Invalid slice step or index out of range

        The square brackets allow access to one or more bits at a time. No
        matter the access scheme (indexing, slicing, or mapping, described
        below), the return value is always shifted to be no more than *N* bits,
        where *N* is the number of bits accessed. E.g., accessing 3 bits will
        return an integer in the range [0, 2\ :sup:`3`), regardless of
        where the are located in the :class:`FixedPointBits`.

        ..  _FixedPointBits_indexing:

        ..  rubric:: Indexing

        When *key* is an :class:`int`, a single bit is accessed in
        :attr:`.FixedPoint.bits`. Index 0 is the LSb and index
        :math:`m + n - 1` is the MSb.

        ..  admonition:: Jump to Examples
            :class: example

            * :ref:`single_bit_slice`

        ..  _FixedPoint_slicing:

        ..  rubric:: Slicing

        When *key* is a :class:`slice` (either an explicit slice object, or
        generated by using one or more ``:``\ s), one or more bits can be
        accessed. With **bits** as :class:`FixedPointBits` and integers **A**,
        **B**, and **C** such that **A** > **B**:

        * ``bits[A:B:C]`` returns bits **A** down to **B** (inclusive) with
          index 0 being the LSb and :math:`m + n - 1` being the MSb. **C** can
          be omitted, but must be -1 if specified.
        * ``bits[B:A:C]`` returns bits **A** up to **B** (inclusive) with index
          0 being the MSb and :math:`m + n - 1` being the LSb. **C** can be
          omitted, but must be 1 if specified.
        * ``bits[A:A:C]`` with **C** == -1 returns bit **A** within index 0
          being the LSb and :math:`m + n - 1` being the MSb.
        * ``bits[B:B:C]`` with **C** == 1 returns bit **B** within index 0
          being the MSb and :math:`m + n - 1` being the LSb.

        Any slicing format not specified above treats the
        :class:`FixedPointBits` as a binary digit :class:`str`
        (indexed from 0 to :math:`m + n - 1`).

        ..  admonition:: Jump to Examples
            :class: example

            * :ref:`multi_bit_slice`

        ..  _FixedPoint_mapping:

        ..  rubric:: Mapping

        Common bit slices are mapped to string keywords:

        +------------+-----------------------+-------------------------------+
        | Key String |       Bit Slice       | Assumptions                   |
        +============+=======================+===============================+
        | ``'m'``    |                       |                               |
        +------------+ integer bits only     | :attr:`.FixedPointBits.m` > 0 |
        | ``'int'``  |                       |                               |
        +------------+-----------------------+-------------------------------+
        | ``'n'``    |                       |                               |
        +------------+ fractional bits only  | :attr:`.FixedPointBits.n` > 0 |
        | ``'frac'`` |                       |                               |
        +------------+-----------------------+-------------------------------+
        | ``'s'``    |                       |                               |
        +------------+                       | | :attr:`.FixedPointBits.s`   |
        | ``'sign'`` | most significant bit  | | is *True*                   |
        +------------+                       +-------------------------------+
        | ``'msb'``  |                       |                               |
        +------------+-----------------------+ --                            |
        | ``'lsb'``  | least significant bit |                               |
        +------------+-----------------------+-------------------------------+

        If the mapping is accessed and the assumption(s) for that mapping are
        not satisfied, a :exc:`KeyError` is raised.

        When the key string is **UPPERCASED**, the return value is a
        :class:`str` of binary bits.

        ..  admonition:: Jump to Examples
            :class: example

            * :ref:`bit_mapping`
